The file name given to the requester is the file that it is requesting and also
the file that it is creating with the response it receives from the sender.

So before running this, you probably want to make a separate directory to run
your requester in, separate from where the sender and the main text files are
located.  (Otherwise they will be overwritten)

THINGS TO DO/KNOW BEFORE RUNNING ANYTHING:
-------------------------------------
 - Pull the code from GitHub.  (New folders, Makefile, etc)
 - Make sure you run 'make all'/'make clean' from the main project directory
 - Make sure you run ./sender ... from the main project directory
 - Make sure you run ./requester ... from the request_dir directory

One thing this makes annoying is that your requester cannot be 'active' when 
you run make, or the new executable will not be created.

10/18 ----------
I didn't push any of the code that I wrote tonight because it's still a mess. I 
think I've figured out that we need to change the way we're sending packets a 
bit.  We can't just send a packet struct because then we're just sending a char*
for the payload.  We need to send the actual bytes of data via sendto(). I'm 
trying to put all the data (type, seq, length, payload) into an allocated char[]
and then send that.  I've got it mostly working but I'm having some problems 
with memcpy()-ing the payload. We should discuss this.


10/19 ---------------
I started on the part where the sender sends the data in the payload, but 
the receiver is segfaulting when trying to read it.  Done for now.  
Hopefully not a tough bug to find.

10/19 PM ----------------
Sender now sends one data packet to the requester from the file requested. We'll
need to figure out how to "chunk" files too large to fit in one packet.  The 
requester also prints out it's data along with writing the payload to the 
correct file.  Also, I think I fixed all the spaces to be tabs so you should see
the source code in your preferred tab width now!

Things still todo (likely only a partial list):
1) Figure out how to "chunk" files if they're size > 1 data packet
2) Figure out how make rate work
3) Send an END packet when the sender is done sending its file
4) Requester prints stats about sender upon receipt on this END packet
5) Request files from senders in correct order (might already do this?)
6) Handle out of order delivary of packets
7) Increment the sequence number when sending packets (see e-mail)
8) Send a 'no-data' data packet if file doesn't exist at sender

10/20 ---------------------
So far I've worked on 3, 4, (5 already done), and you'll have to explain
8 to me.  When the file doesn't exist, I'm sending an END packet.  Obviously
this can easily change.
Some more notes may be available if you check out 'git log' in the command line.

10/20---------------------
I am 'chunking' the file now, and sending it piece by piece.  It's not completely working,
but here is an example of commands to give where things work:
    
    ./sender -p 5000 -g 2000 -r 1 -q 2 -l 2  (send 2 bytes at a time)
    ./requester -p 2000 -o split.txt

This works perfectly, though the sender sends everything at once.  If the total size of the file
you're sending is not divisible by the length given, some weird things can happen.
Mainly, now we need to work on the 'rate' functionality.

10/21 -----------------------
The second demo test doesn't work exactly correctly.  It adds a new line to the 
end of the file when concatenating the split1 to split2.  Need to look into that.

Also, we need to figure out how to actually get the real IP address rather than the 
local host 127.0.0.1 value.  I think we should be able to run this on different computers
at the same time, although that is not in the requirements.

10/21 MATT--------------------
Fixed the newline problem when concatenating two or more files.  The problem was
each file ends with a '\n' by default even if none is typed/entered.  This is 
some kind of convention for files I guess.  
When we fopen() with "a+" that takes us to EOF (seemingly unalterably) which is 
beyond the mandatory '\n' and we start appending there thus the unwanted 
newline.
Now open "r+" (read/write) then fseek() to EOF - 1.  If the file has nothing in 
it then fseek() to EOF - 1 returns an error so I just reopened the file again 
and assume it's empty.  That might be kind of leap of faith but it seems to 
work.

As for the IP addresses I'm still stuck, but on recvfrom() we fill out 
sockaddr_in. We can use char *ip = inet_ntoa(*thingfilledout*.sin_addr) to get 
the IP but you might already know that since kind of already doing that with for
printing.  I'm not sure how to *get* the IP of the machine we're on to set up 
the request packet or data packets.  So I guess we're still stuck there.

Requester still needs to exit politely when it's done but I'm still not really 
clear on how it moves through the tracker list and when it's actually done so 
I'm having trouble with that part. Other than that I think we're pretty much 
finished...
